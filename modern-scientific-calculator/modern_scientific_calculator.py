# -*- coding: utf-8 -*-
"""modern_scientific_calculator

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rE7RkcYDX-oKL3-vZ5mMsU0W2jrs_GHU
"""

#!/usr/bin/env python3
"""
Modern Scientific Calculator (CustomTkinter)
- Modern rounded UI using customtkinter
- Dark theme by default
- Windows-style grid with an expanded scientific section
- Keyboard support: Enter, Backspace, Escape, digits & operators
- Trig functions accept DEGREES by default (toggleable)
- Safe evaluation via restricted eval environment (whitelisted functions)
"""

import customtkinter as ctk
import math
import sys

# ---------------- Configuration ----------------
ctk.set_appearance_mode("dark")        # "dark" or "light"
ctk.set_default_color_theme("blue")    # built-in themes: "blue", "green", "dark-blue"

WINDOW_TITLE = "Modern Scientific Calculator"
WINDOW_SIZE = "480x720"
FONT = ("Roboto", 14)
# ------------------------------------------------

# ---------- Safe math wrappers (degrees mode) ----------
# We will toggle DEG/RAD by wrapping trig functions
ANGLE_MODE_DEG = True  # default: degrees

def _deg_wrap(fn):
    return lambda x: fn(math.radians(x))

def _deg_inv_wrap(fn):
    # inverse trig: returns degrees
    return lambda x: math.degrees(fn(x))

def log10(x):
    return math.log10(x)

def ln(x):
    return math.log

# whitelist of allowed names for eval
SAFE_FUNCS = {
    # trig (we will update these entries on runtime depending on ANGLE_MODE)
    "sin": _deg_wrap(math.sin),
    "cos": _deg_wrap(math.cos),
    "tan": _deg_wrap(math.tan),
    "asin": _deg_inv_wrap(math.asin),
    "acos": _deg_inv_wrap(math.acos),
    "atan": _deg_inv_wrap(math.atan),

    # other math
    "sqrt": math.sqrt,
    "log": log10,   # log(x) -> base-10
    "ln": ln,       # natural log function (call ln(x) -> math.log(x))
    "pi": math.pi,
    "e": math.e,
    "abs": abs,
    "round": round,
}

# helper to refresh trig wrappers when mode toggles
def set_angle_mode_deg(is_deg: bool):
    global ANGLE_MODE_DEG
    ANGLE_MODE_DEG = is_deg
    if ANGLE_MODE_DEG:
        SAFE_FUNCS.update({
            "sin": _deg_wrap(math.sin),
            "cos": _deg_wrap(math.cos),
            "tan": _deg_wrap(math.tan),
            "asin": _deg_inv_wrap(math.asin),
            "acos": _deg_inv_wrap(math.acos),
            "atan": _deg_inv_wrap(math.atan),
        })
    else:
        # raw radians
        SAFE_FUNCS.update({
            "sin": math.sin,
            "cos": math.cos,
            "tan": math.tan,
            "asin": lambda x: math.asin(x),
            "acos": lambda x: math.acos(x),
            "atan": lambda x: math.atan(x),
        })

# initialize properly
set_angle_mode_deg(ANGLE_MODE_DEG)

# ---------- Calculator App ----------
class ModernScientificCalculator(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.title(WINDOW_TITLE)
        self.geometry(WINDOW_SIZE)
        self.resizable(False, False)

        self.expression = ""
        self._create_ui()
        self._bind_keys()

    def _create_ui(self):
        # Top: display frame
        display_frame = ctk.CTkFrame(self, corner_radius=12)
        display_frame.pack(fill="x", padx=12, pady=(12, 8))

        self.display_var = ctk.StringVar(value="")
        self.display_entry = ctk.CTkEntry(
            display_frame,
            textvariable=self.display_var,
            font=("Roboto", 24),
            height=64,
            corner_radius=12,
            justify="right",
            state="normal"
        )
        self.display_entry.pack(fill="x", padx=12, pady=12)

        # Angle mode label + toggle
        ctrl_frame = ctk.CTkFrame(self, corner_radius=8)
        ctrl_frame.pack(fill="x", padx=12, pady=(0,8))
        self.angle_label = ctk.CTkLabel(ctrl_frame, text="Mode: DEG", font=("Roboto", 12))
        self.angle_label.pack(side="left", padx=6)
        self.toggle_button = ctk.CTkSwitch(ctrl_frame, text="Degrees", command=self._toggle_angle_mode)
        self.toggle_button.pack(side="left", padx=6)
        self.toggle_button.select()  # default degrees

        # Buttons: Windows-style expanded layout (scientific block + numeric block)
        buttons_frame = ctk.CTkFrame(self, corner_radius=12)
        buttons_frame.pack(fill="both", expand=True, padx=12, pady=(0, 12))

        # We'll make two subframes: scientific (top) and main grid (below)
        sci_frame = ctk.CTkFrame(buttons_frame, fg_color="transparent")
        sci_frame.pack(fill="x", padx=6, pady=(6,8))

        # Expanded scientific rows (B style)
        sci_rows = [
            ["sin", "cos", "tan", "deg", "rad", "pi", "e", "("],
            ["asin", "acos", "atan", "log", "ln", "sqrt", "x^2", ")"],
            ["x^3", "mod", "1/x", "x^", "C", "⌫", "%", "**"]
        ]
        for row in sci_rows:
            row_frame = ctk.CTkFrame(sci_frame, fg_color="transparent")
            row_frame.pack(fill="x", pady=4)
            for label in row:
                btn = ctk.CTkButton(row_frame, text=label, corner_radius=10,
                                    height=44, font=FONT,
                                    command=lambda x=label: self._on_button(x))
                btn.pack(side="left", expand=True, fill="x", padx=6)

        # Main numeric/operator grid (like Windows)
        grid_frame = ctk.CTkFrame(buttons_frame, corner_radius=8)
        grid_frame.pack(fill="both", expand=True, padx=6, pady=(0,6))

        grid = [
            ["7", "8", "9", "/"],
            ["4", "5", "6", "*"],
            ["1", "2", "3", "-"],
            ["0", ".", "±", "+"],
            ["(", ")", "%", "="]
        ]
        for r, row in enumerate(grid):
            for c, label in enumerate(row):
                btn = ctk.CTkButton(grid_frame, text=label, corner_radius=10,
                                    height=64, font=("Roboto", 18),
                                    command=lambda x=label: self._on_button(x))
                btn.grid(row=r, column=c, sticky="nsew", padx=6, pady=6)
        # Configure grid weights
        for i in range(4):
            grid_frame.grid_columnconfigure(i, weight=1)
        for i in range(len(grid)):
            grid_frame.grid_rowconfigure(i, weight=1)

        # Footer hint
        hint = ctk.CTkLabel(self, text="Enter = Evaluate · Backspace = Delete · Esc = Clear", font=("Roboto", 11))
        hint.pack(pady=(4, 8))

    # ---------- Button handling ----------
    def _on_button(self, label: str):
        label = str(label)
        if label == "C":
            self._clear()
            return
        if label == "⌫":
            self._backspace()
            return
        if label == "=":
            self._evaluate()
            return
        if label == "deg":
            # set degrees
            self.toggle_button.select()
            set_angle_mode_deg(True)
            self.angle_label.configure(text="Mode: DEG")
            return
        if label == "rad":
            self.toggle_button.deselect()
            set_angle_mode_deg(False)
            self.angle_label.configure(text="Mode: RAD")
            return
        if label == "±":
            self._plus_minus()
            return

        # map some friendly labels to expression text
        if label == "x^2":
            self._append_text("**2")
        elif label == "x^3":
            self._append_text("**3")
        elif label == "x^":
            self._append_text("**")
        elif label == "mod":
            self._append_text("%")
        elif label == "1/x":
            # wrap last portion with reciprocal: append "1/(" and rely on user to close or we do auto-close?
            self._append_text("1/(")
        else:
            # for functions like sin, cos, log -> append name + '(' to be user-friendly
            if label in ("sin", "cos", "tan", "asin", "acos", "atan", "log", "ln", "sqrt"):
                self._append_text(label + "(")
            else:
                self._append_text(label)

    def _append_text(self, txt: str):
        self.expression += str(txt)
        self.display_var.set(self.expression)

    def _clear(self):
        self.expression = ""
        self.display_var.set("")

    def _backspace(self):
        if not self.expression:
            return
        # remove last token carefully for '**' case
        if self.expression.endswith("**"):
            self.expression = self.expression[:-2]
        else:
            self.expression = self.expression[:-1]
        self.display_var.set(self.expression)

    def _plus_minus(self):
        # toggle sign of the last number or whole expression if possible
        try:
            val = self._safe_eval(self.expression)
            val = -val
            self.expression = str(val)
            self.display_var.set(self.expression)
        except Exception:
            # fallback: wrap expression
            if self.expression.startswith("-(") and self.expression.endswith(")"):
                self.expression = self.expression[2:-1]
            else:
                self.expression = f"-({self.expression})"
            self.display_var.set(self.expression)

    # ---------- Evaluate safely ----------
    def _safe_eval(self, expr: str):
        # sanitize and replace common chars
        expr = expr.replace("^", "**")
        expr = expr.replace("×", "*").replace("÷", "/")
        # Restrict builtins and use SAFE_FUNCS dict
        allowed_globals = {"__builtins__": None}
        allowed_locals = SAFE_FUNCS.copy()
        # Allow usage of math constants directly via SAFE_FUNCS
        return eval(expr, allowed_globals, allowed_locals)

    def _evaluate(self):
        if not self.expression.strip():
            return
        try:
            result = self._safe_eval(self.expression)
            # format result nicely
            if isinstance(result, float):
                # avoid showing long floats
                result = round(result, 12)
                # convert to int if whole
                if float(result).is_integer():
                    result = int(result)
            self.expression = str(result)
            self.display_var.set(self.expression)
        except Exception as e:
            self.display_var.set("Error")
            self.expression = ""
            # print for debugging
            print("Evaluation error:", e, file=sys.stderr)

    # ---------- Angle mode toggle ----------
    def _toggle_angle_mode(self, *_):
        # toggle based on Switch state
        state = self.toggle_button.get()
        # ctk Switch returns 1/0 - map to bool
        is_deg = bool(state)
        set_angle_mode_deg(is_deg)
        self.angle_label.configure(text=f"Mode: {'DEG' if is_deg else 'RAD'}")

    # ---------- Keyboard handling ----------
    def _bind_keys(self):
        # Evaluate
        self.bind("<Return>", lambda e: self._evaluate())
        self.bind("<KP_Enter>", lambda e: self._evaluate())
        # Backspace
        self.bind("<BackSpace>", lambda e: self._backspace())
        # Escape clears
        self.bind("<Escape>", lambda e: self._clear())

        # digits and operators
        for k in "0123456789.+-*/()%":
            self.bind(k, lambda e, ch=k: self._append_text(ch))

        # caret ^ and multiply characters
        self.bind("^", lambda e: self._append_text("^"))
        self.bind("**", lambda e: self._append_text("**"))

        # letters for functions - allow typing names
        self.bind("<Key>", self._generic_key)

    def _generic_key(self, event):
        ch = event.char
        # ignore control keys
        if not ch:
            return
        if ch.isalpha():
            # accumulate letters (user may type sin(...))
            self._append_text(ch)
        elif ch in "(),":
            self._append_text(ch)
        # else ignore (numbers handled earlier)

# ---------- Run ----------
if __name__ == "__main__":
    app = ModernScientificCalculator()
    app.mainloop()